Exemplos de website em Angular:
  - https://github.com/AndrewJBateman/angular-website-example (bacana)
  - https://github.com/cosmicjs/angular-company-website
  - https://github.com/gothinkster/angular-realworld-example-app
  - https://github.com/kdechant/angular-django-csrf-example (com Django)

Arquivos fontes (repositório) do livro: ng-book: The Complete Guide to Angular 11 (2020)
  - https://github.com/RHieger/ng-book-angular-8
Este livro é muito bom e pode se encontrado em PDF em inglês: https://pt.b-ok.lat/s/?q=ng-book%3A+The+Complete+Guide+to+Angular+11

Instalar pacotes:
    $ npm i json-server

Configuração arquivo package.json:
    "scripts": {
    "start": "json-server --watch db.json --port 3001"
  },

Inicia o servidos backend:
    $ npm start
Acessa o endpoint http://localhost:3001/products , 
para ver o servidor funcionando: GET, PUT, PATCH, DELETE, ETC. no Postman ou curl

Árvore de componentes:

Conceitos importantes:
  Inicialização do app: --> main.ts
    Ele chama o: --> AppModule (componentes dentro dos módulos)
     E ele chama o: --> AppComponent
      -->A partir dele todos os demais componentes serão chamados, ex: 
          --> AppHead, 
          --> AppContent, 
          --> AppFooter, 
          --> etc.

O que é um componente no Angular:
  Um trecho de código que representa um componente visual da tela que será composto
  por um: HTML (estrutura), um CSS (estilo) e um TS (comportamento)
  Ex. de arquivos de um componente:
    --> home.component.css
    --> home.component.htm
    --> home.component.ts
  Obs.: Pode ser colocado tudo em apenas um arquivo (no TS que seria chamado de 
  inline template), mas para efeito de criação de componentes melhor opção será 
  colocar cada elemento da estrutura em arquivos separados

  Quando se cria um componente, para que se possa utiliza-lo é gerada uma tag que irá
  identificá-lo:
    Ex.: <app-home></app-home>
    Assim será encapsulado nesta tag os três elementos necessários do componente:
    a estrutura, o estilo e o comportamento. Essa tag é definida no atributo
	| selector: 'app-home' | no arquivo home.component.htm onde é definido o
	nome da tag.
  
  Ex. da estrutura de comportamento do componente (TS):
    import {Component, OnInit} from '@angular/core';

    @Component({
      selector: 'fenix-home',
      templateUrls: './home.component.html'
      styleUrls: ['./home.component.css']
    })

    export class HomeComponent implements OnInit {

      constructor() {}

      ngOnInit(): void {

      }
    }
  
  - Pode-se observar neste exemplo que pelo menos o componente deve ter o 
  arquivo TS, nele haverá a referência para o arquivo de HTML e CSS;

  Organização dos Módulos:
    - Todos os componentes devem está dentro de um módulo;
    - A árvore de componentes pode ser divida horizontalmente em módulos;
    - Os módulos podem definir a visibilidade de seus componentes; 

  Anatomia do Módulo:

  Module:
      Declarations: (declara todos os elementos que fazem parte do módulo)
        --> components
        --> diretivas
        --> pipes
      Exports: (informa que elementos serão exportados, ou seja visível para fora do módulo)
        --> components
        --> diretivas
        --> pipes
      Imports: (importa outros módulos que o módulo atual seja dependente ou necessite)
        --> Module A
        --> Module B
        --> Module C
      Providers: (Onde serão declarados os service, ver na pática mais a frente ...)
        --> Service A
        --> Service B
        --> Service C
      Bootstrap: (Define o componente que será o primeiro a ser carregado naquele módulo, 
      necessário apena para o módulo que inicia a aplicação; carrega o componente 
      principal na SPA: main.ts --> AppModule --> AppComponent --> ... (que chama os demais componentes da árvore))
        --> AppComponent

  Organização utilizando módulos:

  AppModule                           XModule
    --> Bootstrap                       Declarations | Imports
  Declarations | Imports                Exports      | Providers
          
  YModule                             ZModule 
    Declarations | Imports              Declarations | Imports
    Exports      | Providers            Exports      | Providers

======== Aula 516

CLI do Angular:
  
  Instalando a CLI do Angular de forma global no sistema:
    $ npm i -g @angular/cli
  
  Criando um projeto Angular com estrutura minima, sem teste:
    $ ng new frontendnew --minimal
    
	* Sobre criação de rotas, diz que sim (y): Would you like to add Angular routing? (y/N) y
    * Sobre estilização escolhe-se: CSS
    - Será criada toda a estrutura necessária para trabalhar com o Angular

  Entra na pasta criada do frontendnew:
    $ cd frontendnew
  Inicia o servidor do frontend:
	$ npm start
  Acessa o navegador no endereço:  http://localhost:4200/, para ver a aplicação funcionando
  
======== Aula 517

Ajusta as configurações do arquivo angular.json, nas seguintes configurações:
  "inlineTemplate": false,
  "inlineStyle": false,
Isso é necessário para que os arquivos CSS e HTML fiquem em arquivos separados.
Pois no minimal ele opta por configurar desta forma.

Dentro da pasta do projeto: /frontendnew
    Tem uma pasta chamada:        /src
    Onde ficam os está o:             main.ts (que chama o modulo)
    O AppModule fica dentro da pasta: /app
    Onde estão os arquivos:               app-module.ts (que tem o bootstrap que chama o AppComponent)
                                          app-component.ts (que tem as definições do componente que será renderizado no browser)
                                          app-routing.module.ts (rotas do módulo, estudar mais a frente ...)

Em main.ts é onde está sendo chamado, carregado o nosso módulo principal 
chamado de AppModule que fica na pasta ./src/app/app.module.ts . Nele é chamado
em bootstrap o AppComponent que foi importado e declarado para ser invocado dentro
do AppModule. E por fim ele exporta a si mesmo (AppModule) para ser inicializado por
main.ts.

Podemos observar que AppComponent está com o template no formato inline, 
iremos modificar isso.

- Na pasta /frontendnew/src/assets ficam as images e fontes utilizadas no component.

- Na pasta /frontendnew/src/environments ficam as variáveis de ambiente no 
arquivo environments.ts para desenvolvimento e environments.pord.ts o de produção.

- E temos dentro de /frontendnew/src/index.html que é a SPA (Single Page Application
ou Aplicações de Página Única) que referencia, aponta para o componente raiz através da
tag <app-root></app-root>, pois no arquivo app-component.ts tem como selector: 'app-root',
assim que a aplicação sabe que componente deve carregar, e os outros componentes também serão
carregados nesta nesta única página através do componente raiz.

======== Aula 518

Vamos editar o arquivo app-component.ts para apontar para um arquivo de 
template html e de css externos fazendo o seguinte:
  templateUrl: 'app.component.html',
  styleUrls: ['app.component.css'],
E também vamos criar estes arquivos no mesmo nível da pasta onde está app-component.ts:
  /frontendnew/src/app/app.component.html (Damos este conteúdo ao arquivo: <h1>Component App</h1>)
  /frontendnew/src/app/app.component.css (deixamos este com o conteúdo vazio)

E possível interpolada o valor de uma variável exportada através do uso do {{ }}
no component da em questão, ex.:
  # app-component.ts
  import { Component } from '@angular/core';
  @Component({
    selector: 'app-root',
    templateUrl: 'app.component.html',
    styleUrls: ['app.component.css']
  })
  export class AppComponent {
    title = 'frontendnew'; // title <-- variável em questão
  }
  # E no app.component.html, faríamos
  <h1>Component App</h1>
  <h2>Olá o nome desta aplicação é: {{ title }}</h2> <!-- variável title 
  interpolada através do {{ }} exibindo seu valor no browser. -->

======== Aula 521

Instalando os componentes do Material Design 

1- com a aplicação Angular parada;
2- Executa o seguinte comando:
  $ ng add @angular/material
  Quando da instalação será solicitado escolher as o esquema de cor do projeto,
  selecione o seu preferido:
    * Choose a prebuilt theme name, or "custom" for a custom theme: Indigo/Pink
  Informe se o esquema de tipo de fontes será aplicado para o projeto inteiro:  
    *  Set up global Angular Material typography styles? Yes
  Com relação às animações:
    * Include the Angular animations module? Include and enable animations
  Será feita a instalação conforme as configurações selecionadas.

======== Aula 522

Implementado o componente header (cabeçalho)

Para criar um componente, estando na pasta raiz do projeto frontend (/frontendnew/),
utilizando o terminal, digite o comando:
  $ ng generate component components/template/header # ou de forma resumida
  $ ng g c components/template/header # a ultima parte é o path do component a ser gerado

Serão criado três arquivos no caminho especificado: 
  - header.component.ts;
  - header.component.html; e
  - header.component.css.
  CREATE src/app/components/template/header/header.component.html (21 bytes)
  CREATE src/app/components/template/header/header.component.ts (275 bytes)
  CREATE src/app/components/template/header/header.component.css (0 bytes)
  UPDATE src/app/app.module.ts (604 bytes)
    import { HeaderComponent } from './components/template/header/header.component';
    ...
    declarations: [
    AppComponent,
    HeaderComponent
    ],
    ...
E será atualizado o arquivo app.module.ts que passará a importar o componente 
recentemente criado, conforme visto acima.

Após este processo pode-se ir no app.component.html e acrescentar a tag
<app-header></app-header> isso será suficiente para que o cabeçalho seja
renderizado e irá aparecer no navegador o seguinte: header works! (cabeçalho
funcionando). Agora já podemos trabalhar para estilizar o cabeçalho e deixá-lo
como desejamos.

Vamos trabalhar no template: src/app/components/template/header/header.component.html
mas antes iremos necessitar utilizar um componente que já vem pronto no Material e
temos que importá-lo:
  - No AppModel (src/app/app.module.ts) fazemos o import:
    --> import { MatToolbarModule } from '@angular/material/toolbar'
  
  - Adiciona MatToolbarModule na seção dos importes:
    --> imports: [
      ...
      MatToolbarModule,
      ...
    ]

  - No arquivo header.component.html, faremos a seguinte edição, antes
  adicionamos a imagem logo.png no caminho referenciado:
    <mat-toolbar class="header mat-elevation-z3">
        <span>
            <a>
                <img class="logo" src="assets/img/logo.png" alt="logo">
            </a>
        </span>
        <span class="title-group">
            <a>
                <i class="material-icons">
                    home
                    <!-- dashboard -->
                </i>
                Aplicação CRUD
            </a>
        </span>
    </mat-toolbar>
  
  - Para ajustar a imagem para que fique adequada no tamanho vamos manipular o
  arquivo css header.component.css e estilizar as classes definidas para o header:
    
    .header {
    display: flex;
    align-items: center;
    }

    .header a {
        display: flex;
        align-items: center;
        text-decoration: none;
    }

    .header .logo {
        max-width: 200px;
    }

    .header .title-group{
        padding-left: 25px;
    }

    .header .title-group i {
        padding-right: 5px;
    }

======== Aula 523

Implementado o componente rodapé (Footer)

  1º passo: 
    Para criar um componente, estando na pasta raiz do projeto frontend 
    (/frontendnew/),utilizando o terminal, digite o comando:
      
      $ ng g c components/template/footer # ou de forma resumida
  
  2º passo:
    Já podemos editar o arquivo app.component.html incluindo a tag no componente
    footer que foi criado: <app-footer></app-footer>;
  
  3º passo:
    "Desenhar" com HTML a estrutura do footer e aplicar o estilo necessário
    utilizando o CSS;

    * Estrutura HTML (footer.component.html):

      <mat-toolbar class="footer">
          <span>
              Desenvolvido com
              <i class="material-icons red v-middle">
                  favorite
              </i>
              por <strong>Cod<span class="red">3</span>r</strong>
          </span>
      </mat-toolbar>

    * Estilo CSS (footer.component.css):

      .footer {
          position: fixed;
          bottom: 0;
          display: flex;
          justify-content: flex-end;
      }

      .footer > span {
          font-size: 1.1rem;
          font-weight: 300;
      }


  Exite um arquivo "geral" de estilo CSS que compartilha estilos que são padrões 
  para toda a aplicação. Aqui pode ser definidas classes que podem ser utilizadas
  de forma global na aplicação. Este arquivo fica em ./src/styles.css . Foram
  definidos alguns estilos gerais, também neste aquivo para servir ao footer:
    
    * Estilo Geral CSS (styles.css):

      .red {
          color: rgb(277, 94, 107);
      }

      .v-middle {
          vertical-align: middle;
      }  

======== Aula 524

Implantado o componente de navegação (nav)

  Vamos repetir os mesmos passos da aula anterior só alterando o path de onde os
  arquivos irão ser gerados:

  $ ng g c components/template/nav

  Foram gerados os componentes e agora iremos necessitar utilizar 
  dois componentes que já vem prontos no Material e temos que importá-los:
  - No AppModel (src/app/app.module.ts) fazemos o import:
    --> import { MatSideNavModule } from '@angular/material/sidenav'
    --> import { MatListModule } from '@angular/material/list'
  
  - Adiciona MatSidenavModule e MatListModule na seção dos importes:
    --> imports: [
      ...
      MatSidenavModule,
      MatListModule,
      ...
    ]
  - Inserimos entre header e o footer no arquivo app.component.html 
    a tag no componente de navegação que foi criado: <app-nav></app-nav>
  
  Perceba que assim estamos criando a nossa arvore de componentes dentro de
  nossa app.component.
  
  Fontes de ícones para consulta: https://material.io/resources
  
  Vamos definir agora o nosso nav (para compreender todas as configurações
  do Material é necessário ler a documentação deste módulo para o Angular):

    * Estrutura HTML (footer.component.html):

      <mat-sidenav-container class="container">
          <mat-sidenav class="sidenav" mode="side" opened fixedInViewport="true" fixedTopGap="64">
              <mat-nav-list class="nav-list">
                  <a mat-list-item>
                      <i class="material-icons">
                          home
                      </i>
                      Início
                  </a>
                  <a mat-list-item>
                      <i class="material-icons">
                          storefront
                      </i>
                      Produtos
                  </a>
              </mat-nav-list>
          </mat-sidenav>
      </mat-sidenav-container>

    * Estilo CSS (footer.component.css):

    .sidenav {
    background-color: #3f51b5;
    width: 200px;
    }

    .sidenav a {
        color: #fff;
    }

    .sidenav i {
        padding-right: 10px;
    }

======== Aula 525

Elementos do Angular, aula teórica # 01 de 03

1- Componentes (módulos);

2- Diretivas (altera estilo ou estrutura do HTML);
  * Diretiva de Atributo;
  * Diretiva Estrutural
  
3- Bindes (ligação / comunicação entre TS e HTML): 
  * Property (de atributos), 
    + One Way Data (),
    + Two Way Data ().
  * Event (de evento).

4- Rotas (navegação entre os componentes);
5- Pipes (processamentos dentro da página);
6- Observables (programação reativa);
7- Services;
8- Injeção de dependência;

1. Componentes:
  - Formados por três partes (HTML, CSS e TS), não necessariamente precisa ter o
  estilo (css);
  - O componente tem o seu próprio escopo, seu mundo interno. Isso quer diz que, 
  por exemplo, estilos aplicados ao componente fica restrito ao componente;

2. Diretivas:
    2.1 Diretiva de Atributo:
      - Altera a aparência (alterar o CSS) e/ou comportamento (altera o TS ou JS:
      faz chamada Ajax ao backend, por exemplo) de um elemento, componente ou 
      outra diretiva;

      - Estas diretivas são utilizadas na tag do elemento HTML da seguinte forma,
      ex.: <tag class="name-class" nomeDiretiva></tag>;

      Ex. de uma diretiva de atributo (Attribute Directives):
        @Directive({
            selector: '[appRed]' // <== CHAMADA / APELIDO DA DIRETIVA 
        })
          export class RedDirective {
            constructor(el: ElementRef){
              el.nativeElement.style.color = '#e35e66b';
            }
        }
      => Ex. da chamada da diretiva no HTML >> alterando o estilo / aparência 
        de um elemento:
        
        <i class="material-icons v-middle"> <!-- coração preto -->
          favorite
        </i>
        
        <i class="material-icons v-middle" appRed> <!-- coração vermelho com a chamada da diretiva appRed -->
          favorite
        </i>

    2.2 Diretiva Estrutural:
      - Altera o layout adicionando e/ou removendo elementos do DOM, altera a
      estrutura HTML do elemento;

      - Estas diretivas são utilizadas na tag do elemento HTML precedidas de um
      asterisco, ex.: <tag class="name-class" *nomeDiretiva></tag>; 
      
      Ex. de uma diretiva de estrutura (Structural Directives) que já vem 
      embutida no Angular a *ngIf e a *ngFor. São dois exemplos de vários outros
      que existem no Angular:

      <form *ngIf="product" class="product-form">
      </form>
      => Neste exemplo, se (*ngIf) produto for definido / setado ele será 
      exibido. A condição a ser avaliada é declarada dentro de aspas conforme
      visto acima;
      
      <ul>
        <li *ngFor="let product of products">
        </li>
      </ul>
      => Neste exemplo, Será realizada uma iteração (*ngFor) em products e para
      cada product será exibido um elemento na lista não ordenada. A condição 
      da iteração é declarada dentro de aspas;
  
  3. Binding:
    
    3.1 Property Binding (Binding de Atributo)
      - Quando se quer "pegar" dados / informações que estão nos componentes TS
      e passar para a tag HTML (componentes são pequenas aplicações onde deve 
      existir comunicação entre o arquivo TS com o arquivo HTML) uma das formas 
      de estabelecer esta comunicação entre TypeScript e o HTML é através de 
      Property Binding ou Binding de atributo. Conforme exemplo abaixo:

        => TS
          @Component({
            selector: 'app-product-read',
            templateUrl: './product-read.component.html',
            styleUrl: './product-read.component.css'
          })
          
          export class ProductReadComponent implements OnInit {
            products: Product[] // propriedade product criada como array de Product
          }
        =====> No arquivo TS acima foi criado o componente app-product-read e 
        exposto para fora através da classe ProductReadComponent o atributo 
        products que poderá ser utilizado no HTML do componente para popular uma
        tabela com os respectivos elementos deste array (products).
        
        => HTML
          <table [dataSource]="products">
          </table>
        =====> Para acessar esse array de produtos no HTML é preciso ter algum
        tipo de sintaxe / sinalização para informar que ele irá acessar a variável
        products criada no TS, dentro do componente. E a forma que se tem para
        estabelecer esta comunicação e colocar o atributo que ser quer passar o
        valor da variável entre colchetes []. Como foi realizado no exemplo anterior
        com [dataSource]="products". Se dataSource não for colocado entre [] o
        angular vai interpretar que o valor passado é um string comum igual em 
        uma tag HTML comum. Mas quando é utilizado os colchetes para envolver a 
        propriedade dataSource ele vai olhar para o componente procurando um
        atributo com o nome que se encontra entre aspas "" apos o = que tenha o
        mesmo nome, no caso products. Aí ele vai pegar o array associado a esta
        variável passar para o HTML para montar a tabela de produtos. Então a forma
        que se tem de fazer uma ligação (Binding) entre o HTML e o TS e envolvendo
        as propriedades HTML em colchetes [] e passando o nome da variável TS como
        string para este atributo, dataSource não é um atributo comum para tabela
        porém é utilizado pelo MaterialDesign, que está sendo utilizado, para pode
        renderizar a tabela com seus dados.
      
      3.1.1 On Way Data Binding (Apenas um sentido de ligação de dados) TS --> HTML
        -  Quando se deseja que a comunicação entre o TS e o HTML seja de sentido
        único do TS --> para o HTML a sintaxe utilizada é esta apresentada anteriormente,
        ou seja, utiliza-se os colchetes [] envolvendo a propriedade HTML que irá
        receber o valor da variável quando ela for alterada no TS. Assim as alterações
        no valor da variável só ocorrem no sentido do TS para o HTML, como pode
        ser visto no exemplo abaixo:
          
          => TS
            @Component({
              selector: 'app-product-read',
              templateUrl: './product-read.component.html',
              styleUrl: './product-read.component.css'
            })
            
            export class ProductReadComponent implements OnInit {
              nomeCliente: string // propriedade nome
              //...
              nomeCliente = "Paulo" // variável sofrendo alteração de valor
            }
          =====> O atributo nomeCliente é criado e exposto no TS. Quando seu valor
          é alterado no script ele envia uma notificação para o HTML e altera o 
          valor da propriedade definida lá pelo novo valor da variável.
          
          => HTML
            <input [value]="nomeCliente">
          =====> No HTML a variável nomeCliente é invocada através da propriedade
          value que está sinalizada pela sintaxe de [] no input que irá receber 
          sempre o valor desta variável quando ela for alterada no TS 
          (On Way Data Binding) TS --> HTML .

      3.1.2 Two Way Data Binding (Sentido duplo de ligação de dados) TS <--> HTML
        -  Quando se deseja que a comunicação entre o TS e o HTML seja de sentido
        duplo, ou seja, alterações no conteúdo da propriedade HTML se reflitam no
        TS e vice-versa, a sintaxe para sinalizar este comportamento do biding é
        outra utiliza-se a combinação dos colchetes com os parenteses [()] envolvendo
        a propriedade que se deseja que se comporte como Two Way Data Binding,
        como pode ser visto no exemplo abaixo:
          
          => TS
            @Component({
              selector: 'app-product-read',
              templateUrl: './product-read.component.html',
              styleUrl: './product-read.component.css'
            })
            
            export class ProductReadComponent implements OnInit {
              nomeCliente: string // propriedade nome
              //...
              nomeCliente = "Paulo" // variável sofrendo alteração de valor
            }
          =====> O mesmo exemplo anterior, o atributo nomeCliente é criado e 
          exposto no TS. Quando seu valor é alterado no script ele envia uma 
          notificação para o HTML e altera o valor da propriedade definida lá 
          pelo novo valor da variável e quando o valor for alterado no HTML isso
          também irá alterar o valor no TS do componente. 
          
          => HTML
            <input [(ngModel)]="nomeCliente"> <!-- caso o usurário digite Renato no input isso se refletirá no TS -->
          =====> No HTML a variável nomeCliente é invocada através da propriedade
          value que está sinalizada pela sintaxe de colchetes e parenteses com a
          chamada ngModel dentro  [(ngModel)] no input que irá receber sempre o 
          valor desta variável quando ela for alterada no TS e quando o usurário 
          alterar o valor do input isso se refletirá também 
          no TS (Two Way Data Binding) TS <--> HTML . Esta sintaxe e bastante usada
          para trabalhar com formulários. 

    3.2 Event Binding (Binding de Evento)
      - Quando se deseja ligar, ou seja, fazer um biding entre um evento do HTML
      com um método criado no componente no arquivo TS. Faz-se algo semelhante ao
      biding de atributo com uma pequena diferença: a sintaxe / sinalização para
      isso é modificada ou seja o evento no HTML será envolvido com parenteses ()
      para realizar o biding de evento, conforme exemplo abaixo:

        => TS
          @Component({
            selector: 'app-product-create',
            templateUrl: './product-create.component.html',
            styleUrl: './product-create.component.css'
          })
          
          export class ProductCreateComponent implements OnInit {
            // ...
            createProduct(): void { // método createProduct que será exposto 
              //...
            }
            // ...
          } 
        =====> No arquivo TS acima foi criado o componente app-product-create e 
        exposto para fora através da classe ProductCreateComponent onde o método
        createProduct() poderá ser invocado via biding de evento no HTML do
        componente.

        => HTML
          <button mat-raised-button
            (click)="createProduct()" // evento click envolvido na sintaxe de ()
            color="primary">
            Salvar
          </button>
        =====> Para acessar o método createProduct() no HTML é preciso sintaxe /
        sinalização de () envolvendo o nome do evento que se deseja realizar a
        ligação / biding e logo após o igual = dentro das aspas "" informar o
        nome do método que se deseja invocar acompanhado dos parenteses, conforme
        no exemplo acima, reproduzido aqui: (click)="createProduct()"

  4. Router (Rotas):
    
    - Dado um conjunto de componentes que foram criado deseja-se navegar ou alternar
    entre eles ir e voltar, ex.:
      
      ==> /home    vá para --> [Componente Home] 
      ==> /produto vá para --> [Componente Produto] 
      ==> /usuario vá para --> [Componente Usuário]

    - Então como fazer isso? Faz-se o mapeamento entre uma URL e o componente que
    se deseja exibir, conforme exemplificado acima através do sistema de rotas do
    Angular.

    - Como isso funciona, ex.:
      * Na estrutura da página index.html exite a seguinte estrutura:
        
        + Um componente NAV com as seguintes opções [ HOME | PRODUTO | USUÁRIO ]
        
        + Uma área chamada de [Route Outlet] (ou seja, exibe a saída/componente 
          da rota que foi selecionada). Por exemplo se a rota selecionada for 
          /home clicando no NAV no link HOME, na área de saída da rota será exibido
          o [Componente Home] e assim sucessivamente para os demais links no NAV
          alteração o conteúdo exibido nesta região.
        
        + [Route Outlet] também é um componente e esse componente vai injetar dentro
          dele os componentes de acordo com a navegação que for realizada, em tese,
          representa a região de renderização dos componentes de uma rota.
          ela é definida no nosso template HTML da página index.html (nossa SPA)
          através da tag <router-outlet></router-outlet> ou dentro de um outro
          componente qualquer.
    
    - Abaixo segue um exemplo de trechos de código de como isso funciona:
      
      => nav.component.html [fragmento do html do componente]
        <a routerLink="/products"
          Produtos
        </a>
      =====> A propriedade routerLink vai olhar para o arquivo app-routing.module.ts
      de rotas procurando um objeto na lista Routes que possui uma propriedade 
      path que seja igual a string informada, encontrado o path que coincide 
      retorna o componente que está mapeada no objeto na propriedade component,
      conforme fragmento abaixo.
      
      => app-routing.module.ts [fragmento do html do componente]
      const routes: Routes = [{
          path: "products",
          component: ProductCrudComponent
        }, {
          path: "products/create",
          component: ProductCreateComponent
        }];
      =====> Neste caso, localiza o path products então carrega e retorna 
      o component ProductCrudComponent que será injetado no componente 
      router-outlet para que seja renderizado, conforme fragmento a seguir.

      => nav.component.html [fragmento do html do componente, que poderia ser outro qualquer]
        <mat-sidenav-content>
            <router-outlet></router-outlet>
        </mat-sidenav-content>
      =====> Neste exemplo, o componente ProductCreateComponent será injetado
      dentro de router-outlet que está inserido em um outro componente 
      mat-sidenav-content .

  5. Pipes (Processamentos de variáveis no HTML):
    
    - São processamentos realizados em cima de variáveis no HTML. Uma das 
    características dos pipes é a possibilidade de conectar o resultado obtido
    com um processamento de um pipe e passá-lo para ser processado em outro 
    pipe como se fosse conexões de tubos um encadeamento, veja exemplos:

    => Pipe para processamento de datas:
    <p>
      O vencimento é {{ produto.vencimento | date }}
    </p>
    =====> Suponhamos que o formato da data que vem do banco de dados é o que se
    adequada para ser exibido para o usuário, nesse caso estamos processando para
    exibir a data, aplicando uma formatação diferente.

     => Pipe também podem receber parâmetros, como no caso no exemplo a seguir:
    <td>
      {{ row.price | currency: 'BRL' }}
    </td>
    =====> Processa o preço para que se apresente no formato de moeda e recebe o
    parâmero após os : com 'BRL' para identificar que é no formato da moeda do
    Brasil. Por baixo dos panos o pipe chama uma função para realizar o processamento.

    => Pipe realizando processamentos em cadeia (chaining):
    <p>
      O vencimento é {{ produto.vencimento | date: 'fullDate' | uppercase }}
    </p>
    =====> No caso acima recebemos uma data processamos para mostrá-lo completa
    por extenso e depois processamos novamente para colocar tudo em letras 
    maiúsculas.

======== Aula 526

Elementos do Angular, aula teórica # 02 de 03

6. Observable (Programação Reativa - ReactiveX):
  
    * import { Observable } from "rxjs"
  
  - O Angular utiliza por baixo dos panos o framework rxjs para trabalhar com o
  conceito de programação reativa. Ou seja, o código passa a agir de acordo com
  a ocorrência de algum evento esperado, onde este evento está sendo monitorado
  por um Observable que comunica o fato a um outro código interessado. Esse 
  framework utiliza a implementação do padrão de projeto Observer (Padrão de 
  projetos mais usado na web).

  - O que é o padrão de projeto Observer:
    
    => É um padrão orientado a evento. É a base da programação reativa. Exite 
    uma entidade nomeada de:
      * Subject: que é responsável por monitorar um determinado evento. As entidades
      interessadas em determinado evento delegam esta função para este intermediário,
      assim elas ficam "livres" para fazer outras coisas enquanto o evento não ocorre.
      Quando o Subject detecta a ocorrência de um evento ele consulta a lista de todos
      os Observes (interessados) no evento então ele notifica os Observers sobre
      esta ocorrência. Ele é o intermediário entre o evento e os interessados em
      saber que o evento ocorreu.

    E exitem outras entidades chamadas de:
      * Observer: que são as entidades que estão interessadas na ocorrência / 
      acontecimento do evento monitorado pelo Subject. Cada Observer deve se
      registar no Subject sinalizando seu interessem em acompanhar determinado 
      evento. Quando um Observer é notificado sobre a ocorrência de um evento ele
      executa internamente uma função diante da ocorrência do evento esperado;

    E exitem os:
      * Eventos: é um acontecimento esperado por um Observer e monitorado por um
      Subject.
  
    => Ex.: Em um Sistema de E-Commerce:
      ==> Evento: Compra <-- monitorado pelo Subject
        ---> Observer interessados no evento:
          |-> Enviar e-mail para o usuário;
          |-> Dar baixa no estoque;
          |-> Enviar mensagem para outro sistema para separar a mercadoria,
          |-> etc.
  - A reatividade no JavaScript passa ser possível a partir do momento que é se
  utiliza uma função como parâmetro para outra função. Essas funções chamadas de
  callbacks. 
    => Ex. chame esta função quando a resposta da requisição chegar.
  
  - Promises são callbacks, porém  diferente das callbacks originais que criam um
  "inferno" de camadas de funções umas dentro das outras, as Promises tem a capacidade
  de realizar o encadeamento de várias chamadas, consegue compor melhor várias chamadas
  sem ter esse inferno de aninhamento de funções. Uma característica da Promise é
  quando ela é finalizada não há mais condições de reutilizá-la, com a evolução
  foi possível unir a facilidades das Promises com outros benefícios aí surgem o:
    
    * Observables: estão dentro do rxjs que o Angular utiliza. Ele vai encapsular 
    o padrão Observer e fornecer outras ferramentas poderosas que possui as 
    seguintes características:

      + Reusável: diferente da Promise é possível ser reutilizado;
      
      + Stream de Dados: Consegue monitorar um fluxo de dados ex. uma votação em 
      tempo "real" atualizados os votos que foram dados ou apurados. Fica recebendo
      um fluxo de dados de forma constante sem a necessidade de criar novos objetos
      para realizar este monitoramento;
      
      + Operadores: exite uma serie de operadores, que são funções, que é possível
      utilizar junto com os Observables. As Promises tem o then(), já aqui tem o 
      map(), filter(), etc. Já vem com essas funções embutidas para serem utilizadas,
      que ajudam a processar os dados recebidos. 

    => Ex. de um Observable:
    - Via de regra, quando se está utilizando estes recursos (Promise, Observable, etc.) 
    estamos trabalhando com chamadas assíncronas ou seja não há uma resposta 
    imediata no para a solicitação realizada. Um exemplo disso é quando se faz 
    uma chamada para o backend da aplicação.
    
    ===> product.service.ts
        ...
        import { Observable } from "rxjs";
        import { HttpClient } from "@angular/common/http";
        import { Product } from "./product.model";
        ...
        baseUrl = "http://localhost:3001/products";
        constructor(private http: HttpClient) {}
        ...
        criarProdutoNoBackend(product: Product): Observable<Product> { // <-- Foco neste método
            return this.http.post<Product>(this.baseUrl, product);
        }
      --> Faz uma requisição do tipo HTTP POST para o backend da aplicação que pode
      demorar alguns segundos para responder. Não responde de forma imediata e sim
      em algum momento no futuro. Por isso esse método retorna um Observable ou 
      poderíamos também chamar de Subject e aí no método criarProduto() do 
      arquivo product.service.ts vai registar / inscrever um observador (Observer)
      através do método subscribe().  

    ===> product.service.ts
        ...
        import { Product } from './../product.model';
        import { ProductService } from './../product.service';
        ...
        product: Product = {
          name: '',
          price: null
        }
        constructor(private productService: ProductService) { }
        ...
        criarProduto(): void { // <-- Foco neste método
          this.productService.criarProdutoNoBackend(this.product).subscribe(() => {
            this.productService.exibirMensagem('Produto salvo com sucesso!');
          });
        }
      --> Aqui o método subscribe() está registrando um observador (Observer) 
      que é uma função anônima do tipo arrow sem parâmero que invoca um método 
      para exibir uma mensagem. O Observable tem a capacidade que um determinado
      evento aconteceu que é a resposta do backend, neste caso, para requisição
      POST e quando esta resposta chegar o método que foi passado para o subscribe()
      será chamado. Pode ocorre um conjunto de fatores quando a responta retornar:
      exibição de mensagem; mudança de tela; envio de e-mail; etc...
      A retorno do método criarProdutoNoBackend é um Observable --> mas a resposta
      do servidor backend ainda não chegou --> o subscribe() registra um (Observador)
      Observer que aqui é uma função --> quando a resposta do servidor chegar esta
      função observadora será disparada / executada.


======== Aula 527

Elementos do Angular, aula teórica # 03 de 03

7. Services ():

  - São classes que têm como principal objetivo organizar e compartilhar código
  (métodos e dados, que são membros de uma classe) entre os componentes, diretivas e 
  compartilhar também dados, ex. um contador dentro do service.
  A ideia é separar as responsabilidades. Tudo aquilo que é de respeito a visualização
  do componente (parte visual do mesmo), agora sempre que se tem regras de negócio
  que devem ser encapsuladas para acesso a API ou backend da aplicação o ideal É
  separar as responsabilidades: algumas delas devem ser colocadas no Service do 
  componente, tudo aquilo que não é de responsabilidade visual e sim de acesso ao
  backend; e para viabilizar a comunicação entre componentes, compartilhar 
  (métodos e dados). O Angular não vai força a criação de Services.

  -Motivação para o Service: quando os componentes compartilham uma determinada
  lógica de negócio ou essa lógica que está no componente não se refere a parte 
  visual do mesmo e/ou está se repetido em vários componentes; isto é uma boa 
  Motivação para criar um service, ex.:
  +----------------+              +----------------+
  | Componente #01 |              | Componente #02 |
  |   HTML |  CSS  |              |   HTML |  CSS  |
  |       TS       |              |       TS       |
  | Log.01 | Log.x |              | Log.02 | Log.x |
  | Log.y  | Log.z |              | Log.y  | Log.w |
  +----------------+              +----------------+
  => No exemplo temos dois componentes que compartilham a lógica x, y, z e w, que são
  regras de negócio e não fazem parte da visualização do componente. E cada
  um deles possui uma lógica própria que não é compartilhada (lógica 01 e 02),
  que são lógicas ligadas a parte visual do componente. Neste caso, é possível
  remover estas lógicas dos dois componentes (lógicas x, y, z e w) e colocá-las em
  um service, veja: 
                    +----------------+
                    |    Service     |
                    | Log.x  | Log.y |
                    | Log.z  | Log.w |
                    +----------------+
  => Mesmo as lógicas z e w que não estão duplicadas mas não fazem parte da visualização
  do componente e não fazem sentido estar dento dele, elas podem ser deslocadas 
  para o service. Uma observação importante é um service deve agrupar lógicas coerentes
  com o tema a que se propõe o service, assim sendo, um componente pode ter mais
  de um service com lógicas coerentes que aglutina dentro de si. O SERVICE DEVE
  CONTER UM GRUPO COERENTE DE FUNCIONALIDADES PARA DETERMINADO COMPONENTE.
  Ex. Cadastro de Produto: um service que aglutina todas as funcionalidades de um
  CRUD neste service, porém na hora do Cadastro de Clientes as funcionalidades
  deste componente não é recomendando misturar com as funcionalidades de Cadastro
  de Produtos. O componente deve se forcar mais na parte visual, de renderização.

  ==> Para criar um componente usamos:
      $ ng generate service services/product # ou de forma resumida
      $ ng g s services/product # a ultima parte é o path do service a ser gerado

  ===> Representação de um classe que exprime um service:
      product.service.ts (atenção para a guideline / diretriz para nomeação de arquivos no Angular)
        ...
        @Injectable({
          providedIn: "root",
        })
        export class ProductService {
          ...
        }

      * Uma coisa importante sobre este código é o decoration @Injectable: O que
      está sendo dito em linhas gerais é o seguinte, que esta classe será detectada 
      pelo Angular e será possível injetá-la em outras classes. Isso irá possibilitar
      por exemplo utilizar o service dentro dos componentes através da injeção de
      dependência.
      
      * Outra coisa é a chave providedIn: "root" : esta chave está sinalizado que
      o injetor é o injetor raiz da aplicação. Só existe um injetor raiz da aplicação
      e isso significa que no contexto de toda a aplicação só existirá um único
      ProductService, por exemplo. Sempre que for injetado o product service em
      um componente qualquer o Angular sempre irá retornar a mesma instância, este
      comportamento está relacionado ao padrão de projeto Singleton, onde é criado
      uma única instancia de uma classe através de um construtor privado fornecendo
      um método get que retorna sempre a mesma instância criada. O Angular faz tudo
      isso por baixo dos panos.
        
        + root é um apelido ou alias para o nome da nossa aplicação real o AppModule.
        Ele é o que se chama de RootInjector (o injetor principal). Quando se diz
        que o providedIn é o "root" é o mesmo que dizer que é o AppModule. Podemos
        substituir o nome "root" pela referencia do módulo AppModule (fazendo o 
        import do modulo antes) que é a mesma coisa, neste caso o escopo deste 
        service será AppModule que é o módulo raiz (root).

        + Um injector pode ser de dois tipos: isso altera o escopo de utilização
          de um determinado service

          1> ModuleInjector: restringe o escopo de atuação de determinado módulo:
            
            a) @NgModule: significa que dentro do escopo do módulo será gerada
              apenas uma única instância do service sinalizado com esta annotation
              (@NgModule) e que é referenciado em Providers (este services).
            
            b) @Injectable: pode-se da mesma forma ter apenas uma instância para
              toda aplicação se associado ao modulo raiz dela (root) ou para apenas
              um determinado módulo que seja definido ex.: módulo de autenticação
              AuthModule:
              @Injectable({
                providedIn: AuthModule,
              })

          2> ElementInjector:
            a) @Directive: dentro de uma diretiva (de atributo ou estrutural) 
              pode definido nesta annotation para a chave "providers:" uma lista
              de services que se deseja adicionar nesta diretiva do componente.
              Está informando que se quer ter uma instância de cada service
              própria dentro desta diretiva específica de um componente. A instância
              será dedicada para a diretiva especificada.

            b) @Component: dentro de um componente pode definido nesta annotation
              para a chave "providers:" uma lista de services que se deseja 
              adicionar neste componente específico apenas. Está informando-se 
              que se quer ter uma instância de cada service própria dentro do 
              componente específico. A instância será dedicada para o componente
              especificado.

          + Em aplicações mais complexas é bom saber definir o escopo de cada 
            services a depender de cada módulo ou elemento. Restringindo o acesso
            aos services, de acordo com o escopo desejado e necessário. mais
            informações na documentação: http://angular.io/guide/hierarchical-dependency-injection

8. Injeção de Dependência ():

  - É um padrão no qual a classe recebe as dependências de uma fonte externa ao
  invés de cria por conta própria, ou seja, no cenário em que uma classe A precisa
  da classe B, a classe A vai criar uma instância da classe B, porém na injeção de
  dependência isso vai ser invertido, ou seja, é um padrão onde a classe dependente (A)
  recebe a dependência de uma fonte externa ao invés de criar por conta própria.
  Assim a classe A ao invés de instância a classe B ela recebe de uma fonte externa,
  como por exemplo pelo construtor ou outro mecanismo (@decoration), uma instância da
  classe B da qual é dependente. Dependendo da linguagem e do framework que será
  utilizado a forma de implementação da injeção de dependência pode ser diferente.

  => Um exemplo, cenário SEM Injeção de Dependência:
    class Carro {    --------- depende ---->  class Motor {
      motor: Motor                            
      constructor(){                          }
        this.motor = new Motor()
      }
    }
  ==> Neste caso acima a classe carro depende da classe motor e está instanciando
  o motor no construtor, automaticamente quando uma nova instância de carro é 
  criada. Neste caso quem foi RESPONSÁVEL por instancia a classe motor foi o carro.
  Não há injeção de dependência. Nesse caso se algo mudar em motor tipo, for 
  necessário adicionado quantidade de cilindros para instanciar um motor vai gerar
  um quebra no código na instanciação do carro, pois dentro do construtor do não
  há previsão de número de cilindros para o motor, logo isto é um problem, como
  resolver isso? Qual a solução para o problema abaixo?

    class Carro {    ---- instancia um -----------> class Motor {
      motor: Motor                                    cilindrada: number // <- mudança novo atributo necessário para construir a classe
      constructor(){                                  constructor(cilindrada: number) { 
        this.motor = new Motor() // <- erro aqui          this.cilindrada = cilindrada
      }                                               }
    }                                                }

  => Neste outro exemplo COM Injeção de Dependência:
    class Carro {    <------- recebe um ------------------- class Motor {
      motor: Motor                                            cilindrada: number // <- mudança novo atributo necessário para construir a classe
      constructor(motor: Motor){ // <- injetando dep. ext.     constructor(cilindrada: number) { 
        this.motor = motor                                     this.cilindrada = cilindrada
      }                                                       }
    }                                                        }
  ===> No exemplo acima carro agora depende que alguém, por exemplo uma fábrica,
  instancie um motor e passe-o para o construtor da classe Carro. O carro agora
  não precisa se preocupar com as mudanças que são realizadas em motor, apenas
  necessita receber uma instância de motor para construir o carro, isso é injeção
  de dependência. O framework Angular irá se incubi de criar a instância e injetá-la
  na classe decorada que necessita daquela dependência.

  Estamos solucionado um problema de Inversão de Controle através
  da Injeção de Dependência (pattern), que são coisas distintas. Aqui o problema
  foi resolvido através do Constructor Injection, ou seja, injetamos uma dependência 
  de uma classe através do construtor desta classe. Já inversão de dependência é
  a estratégia de depender de interfaces ou classes abstratas, ao invés de 
  classes concretas.
  Fontes para estudar:
  https://www.devmedia.com.br/inversao-de-controle-x-injecao-de-dependencia/18763
  https://pt.stackoverflow.com/questions/21319/quais-as-diferen%C3%A7as-entre-inje%C3%A7%C3%A3o-de-depend%C3%AAncia-e-invers%C3%A3o-de-controle
  https://medium.com/contexto-delimitado/o-princ%C3%ADpio-da-invers%C3%A3o-de-depend%C3%AAncia-d52987634fa9

  => Injeção de Dependência no Angular: Dentro do Angular exite um framework para
  injeção de dependência (um framework dentro do framework).
  Toda vez que uma classe é decorada com @Injectable estamos dizendo para o Angular
  que essa classe pode ser: 
    (1)- Injetada em outra classe; e que 
    (2)- E que o Angular deve instanciar esta classe automaticamente para ser
    utilizada, na maioria dos casos existirá apenas um instância para toda a 
    aplicação, um Singleton;
  
  ===> No momento em que o Componente for ser criado, o Angula como já tem na
  memória uma instância, por exemplo, de um Service que o componente necessita 
  em seu construtor, nesse momento o Angular passa este Service (Singleton) para
  o construtor do componente que instancia-o e coloca na memória à disposição para
  ser utilizado.

    * Singleton: services são Singleton (apenas uma instância) dentro do escopo 
    de um injector.
  
======== Aula 528

Componente inicio (Home / Início)

Para criar um novo componente que irá representar a página Home / Início /
Landing Page iremos utilizar o seguinte comando, informando o path onde será
criado o componente (cada desenvolvedor deve criar sua organização de como
os componentes serão criados e agrupados de forma coerente, aqui foi adotado
que os componentes que representam as páginas serão criados dentro de uma pasta
chamada de views que seriam as páginas às visões de cada página a ser exibida),
assim o caminho ficara assim views/home que será criado dentro da pasta do projeto
atual em /src/app/views/home e os arquivos serão criados e nomeados da seguinte
forma: 
  - home.component.css ;
  - home.component.html ; e
  - home.component.ts

$ ng generate component views/home # ou
$ ng g c views/home

Dentro da pasta components foi previsto para serem salvos neste caminho 
(/src/app/components/...) os componentes de dois tipos:
  
  - templates: que são partes fixas e que pertencem à maioria das páginas a serem
    exibida (/src/app/components/templates/...) com por exemplo:
      * header (cabeçalho) (/src/app/components/templates/header);
      * nav (navegação - sidenav e side-content) (/src/app/components/templates/nav);
      * footer (rodapé) (/src/app/components/templates/footer);

  - product: onde serão aglutinados todos os componentes relacionados aos produtos
    utilizados neste exemplo de crud. Nesta pasta também ficarão os services e 
    model relacionados ao mesmo componente;
  
  - views: onde serão aglutinados os componentes responsáveis pela exibição de
  uma "página inteira", que será localizado dentro de um container do mat-sidenav-container.
  Estes componentes representam páginas onde será possível realizar navegação entre elas.

Vamos continuar no procedimento de implantação da página Home / inicio:

  1- No arquivo nav.component.html iremos adicionar, após </mat-sidenav> o componente
  app-home dentro do mat-sidenav-content que é o componente responsável por apresentar
  o conteúdo da navegação do mat-sidenav e das demais rotas necessária para o
  funcionamento deste CRUD, o seguinte conteúdo:
    <mat-sidenav-content class="content">
        <app-home></app-home> <!-- nosso componente que representa a view home, que será substituído em breve por um router para permitir a navegação em diversas telas (páginas, view ou componentes) diferentes -->
    </mat-sidenav-content>
  => Pode ser utilizada alguma classe de estilização para melhorar esta apresentada
  através do arquivo nav.component.html para estilizar a classe que definimos como
  class="content" na tag deste componente, com o seguinte:
    .content {
      padding: 16px;
      background-color: #fff;
    }

  2- Dentro do app.module.ts iremos importar mais um componente que irenos necessitar
  para utilizar dentro do componente home, o componente é o card do Material, fazendo
  o seguinte:
  Dento de app.module.ts faremos o import de:
    ...
    import { MatCardModule } from '@angular/material/card'
    ...
  E neste mesmo arquivo vamos adicionar o módulo importado na chave import que é
  uma lista:
    import: [
      ...
      MatCardModule,
      ...
    ]

  3- Agora podemos utilizar os componentes deste módulo em nossa aplicação. Iremos
  adicionar dentro co componente home.component.htm o seguinte código:
    <mat-card class="home mat-elevation-z4">
      <mat-card-title class="title">
          Seja bem-vindo!
      </mat-card-title>
      <mat-card-subtitle class="subtitle">
          Sistema exemplo para cadastro (CRUD) em Angular
      </mat-card-subtitle>
    </mat-card>  
  => E iremos aplicar a seguinte estilização através do arquivo home.component.css:
    .home .title {
      font-size: 3rem;
      font-weight: 300;
      line-height: 1.2;
    }
    .home .subtitle {
      font-size: 1.1rem;
    }
  => class="mat-elevation-z4" : classe de estilização é integrada a este elemento
  e dará um efeito 3d com sombra e elevação de destaque ao nosso card, consute a
  documentação do material para maiores detalhes em: https://material.angular.io/guide/elevation


======== Aula 529

Navegando entre componentes

Vamos criar agora nosso componente view que irá abrigar os demais componentes para
realizar o cadastro de produtos. Ele será chamado de product-crud. Nele será possível
chamar as quatro operações: Create, Read, Update e Delete. Para cada operação poderíamos
ter uma tela específica. Create e Update poderiam compartilhar a mesma tela, por exemplo.
O Delete não necessita de uma tela específica, pode ser utilizado, por exemplo, um botão ao
lado do produto na tela Read.

Este componente seria como um "roteador" entre as demais componentes do CRUD, onde
todos os demais componentes estariam "dentro" dele e seriam chamados conforme a
necessidade.

1- Vamos criar este componente com o comando já conhecido:
  $ ng g c views/product-crud

  Teremos dentro da pasta /src/app/view/product-crud os arquivos de nossa app.

2- Vamos para o template de nosso componente de navegação e alteramos provisoriamente
  o código de componente mat-sidenav-content para:
    ...
    <mat-sidenav-content class="content">
      <app-product-crud></app-product-crud>
    </mat-sidenav-content>
    ...

  Após salvar o arquivo nav.component.html será possível visualizar o componente 
  sendo renderizado na tela com o texto: "product-crud works!". Mas o que queremos
  é ao clicar nos botões do sidenav navegar entre as views home, product-crud, etc
  sem precisar ficar mudando manualmente como fizemos acima, para isso iremos utilizar
  o esquema de rotas do angula que já vem integrado e pronto para que possamos usar.
  Ele também tem o comportamento de um componente. E iremos fazer o seguinte:

3- No arquivo nav.component.html onde tem <app-product-crud></app-product-crud>
  nós iremos substituir por <router-outlet></router-outlet>. Isso significa que
  o componente/sistema de rotas incluído na criação na inicialização será utilizado
  para navegar entre as telas/componentes/views do nosso sistema, o template agora
  ficará assim:
    ...
    <mat-sidenav-content class="content">
      <router-outlet></router-outlet>
    </mat-sidenav-content>
    ...

4- Dentro de src/app/app-routing.module.ts nós iremos adicionar nossos objetos que
  representam rotas dentro do array chamado de Routes, neste aquivo, a estrutura básica
  de cada objeto desta lista deve ser:
    a) path: define a url ou caminho para o recurso que estamos querendo carregar/renderizar na tela;
    b) component: define o nosso componente (página/template/view) associado ao path definido acima;
    c) title: define qual o título nossa página deve ter ao navegar para o path definido.
  Este são apenas alguns dos atributos possíveis para este tipo de objeto Route.

  Deste modo faremos a inserção dos seguintes objetos Router no Array Routers:
    ...
    // importes necessários para serem utilizados nas rotas
    import { HomeComponent } from './views/home/home.component';
    import { ProductCrudComponent } from './views/product-crud/product-crud.component';
    ...
    const appName: string = "MyCRUD"
    const routes: Routes = [
      {
        path: "",
        component: HomeComponent,
        title: appName + " | " + "Home",
      },
      {
        path: "products",
        component: ProductCrudComponent,
        title: appName + " | " + "Produtos",
      }
    ];
    ...

  Acima temos duas rotas básica:
    - A rota raiz (root): definida por uma string em vazia "", que a representa,
      que vai renderizar a nossa view home;
    - A rota para produtos: definida por uma string "products", que irá renderizar
      nosso CRUD de produtos.
  
5- Agora iremos em nav.component.html para adicionar a propriedade routerLink=""
  nas tags <a>, em nosso caso, para permitir a navegação através no sidenav,
  conforme código abaixo:
  ...
  <mat-nav-list class="nav-list">
    <a mat-list-item routerLink=""> <!-- rota para navegação para view de Home -->
        <i class="material-icons">
            home
        </i>
        Início
    </a>
    <a mat-list-item routerLink="products"> <!-- rota para navegação para view de CRUD de produtos -->
        <i class="material-icons">
            storefront
        </i>
        Produtos
    </a>
  </mat-nav-list>
  ...

6- Outro ajuste é ao clicar na logo mudar para a página home, vamos abrir o arquivo
  header.component.html e fazer o seguinte ajuste:
  ...
  <span>
    <a routerLink="">  <!-- rota para navegação para view de Home, a rota raiz da aplicação -->
        <img class="logo" src="assets/img/logo.png" alt="logo">
    </a>
  </span>
  ...


======== Aula 530

Diretivas na prática # 01 de 02 (DIRETIVA DE ESTILIZAÇÃO)

-Exemplo de DIRETIVA DE ESTILIZAÇÃO (apenas como mecanismo de aprendizagem),
vamos CRIAR E USAR a diretiva (que pode ser em uma tag HTML ou em um componente):

No componente footer (src/app/components/template/footer/footer.component.html)
exite um coração que foi definido em vermelho por uma classe css chamada de red em
style.css. Vamos criar uma diretiva de estilização para modificar a cor da
tag/elemento no lugar da classe css, para isso faremos o seguinte:

1- Criaremos uma diretiva através do comando:
  $ ng g d directives/red # será criada uma diretiva chamada red na pasta src/app/directives/

Com isso foi criado o arquivo red.directive.ts no caminho especificado e foi atualizado
o app.module.ts com o import desta diretiva e na declaração também.

2- Vamos abrir o arquivo red.directive.ts e realizar as seguintes alterações:
  a) Injetar uma dependência do elemento que queremos modificar através de inclusão
    de um atributo privado no construtor da diretiva; esse atributo será do ElementRef;
    ...
    constructor(private el: ElementRef) { }
    ...

3- Dentro do construtor iremos informa que o elemento nativo ira receber um estilo
  de cor que iremos definir com #e35e6b, que é a cor que esperamos que o nosso
  coração tenha:
  ...
  el.nativeElement.style.color = '#e35e6b'
  ...

4- Definir o seletor de nossa diretiva, ele foi definido automaticamente como appRed
  mas nada impede que de que ele seja alterado para outro nome;
  ...
  @Directive({
    selector: '[appRed]' // <-- nome do seletor de nossa diretiva
  })
  ...

5- Vamos para o arquivo footer.component.html e lá faremos uso de nossa diretiva
  criada. Iremos aplicá-la na tag desejada através do nome do seletor dela appRed,
  conforme podemos ver abaixo, removendo a classe red css que foi aplicada anteriormente
  e aplicado na tag fora das aspas nossa diretiva:
  ...
  <i class="material-icons v-middle" appRed> <!-- nossa diretiva aplicada aqui -->
    favorite
  </i>
  ...

Podemos fazer a atualização da página para verificar que nossa diretiva foi aplicada
com sucesso.

======== Aula 531

Diretivas na prática # 01 de 02 (DIRETIVA DE ESTRUTURAL)

-Exemplo de DIRETIVA DE ESTRUTURAL (apenas como mecanismo de aprendizagem).

----------------------------------------------------------------------------
Alterando cabeçalho da App  
Comunicação de dados entre componentes com service (alterando o conteúdo de
outro componente)

