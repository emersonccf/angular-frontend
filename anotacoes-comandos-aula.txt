Exemplos de website em Angular:
  - https://github.com/AndrewJBateman/angular-website-example (bacana)
  - https://github.com/cosmicjs/angular-company-website
  - https://github.com/gothinkster/angular-realworld-example-app
  - https://github.com/kdechant/angular-django-csrf-example (com Django)

Instalar pacotes:
    $ npm i json-server

Configuração arquivo package.json:
    "scripts": {
    "start": "json-server --watch db.json --port 3001"
  },

Inicia o servidos backend:
    $ npm start
Acessa o endpoint http://localhost:3001/products , 
para ver o servidor funcionando: GET, PUT, PATCH, DELETE, ETC. no Postman ou curl

Árvore de componentes:

Conceitos importantes:
  Inicialização do app: --> main.ts
    Ele chama o: --> AppModule (componentes dentro dos módulos)
     E ele chama o: --> AppComponent
      -->A partir dele todos os demais componentes serão chamados, ex: 
          --> AppHead, 
          --> AppContent, 
          --> AppFooter, 
          --> etc.

O que é um componente no Angula:
  Um trecho de código que representa um componente visual da tela que será composto
  por um: HTML (estrutura), um CSS (estilo) e um TS (comportamento)
  Ex. de arquivos de um componente:
    --> home.component.css
    --> home.component.htm
    --> home.component.ts
  Obs.: Pode ser colocado tudo em apenas um arquivo (no TS que seria chamado de 
  inline template), mas para efeito de criação de componentes melhor opção será 
  colocar cada elemento da estrutura em arquivos separados

  Quando se cria um componente, para que se possa utiliza-lo é gerada uma tag que irá
  identificá-lo:
    Ex.: <app-home></app-home>
    Assim será encapsulado nesta tag os três elementos necessários do componente:
    a estrutura, o estilo e o comportamento. Essa tag é definida no atributo
	| selector: 'app-home' | no arquivo home.component.htm onde é definido o
	nome da tag.
  
  Ex. da estrutura de comportamento do componente (TS):
    import {Component, OnInit} from '@angula/core';

    @Component({
      selector: 'fenix-home',
      templateUrls: './home.component.html'
      styleUrls: ['./home.component.css']
    })

    export class HomeComponent implements OnInit {

      constructor() {}

      ngOnInit(): void {

      }
    }
  
  - Pode-se observar neste exemplo que pelo menos o componente deve ter o 
  arquivo TS, nele haverá a referência para o arquivo de HTML e CSS;

  Organização dos Módulos:
    - Todos os componentes devem está dentro de um módulo;
    - A árvore de componentes pode ser divida horizontalmente em módulos;
    - Os módulos podem definir a visibilidade de seus componentes; 

  Anatomia do Módulo:

  Module:
      Declarations: (declara todos os elementos que fazem parte do módulo)
        --> components
        --> diretivas
        --> pipes
      Exports: (informa que elementos serão exportados, ou seja visível para fora do módulo)
        --> components
        --> diretivas
        --> pipes
      Imports: (importa outros módulos que o módulo atual seja dependente ou necessite)
        --> Module A
        --> Module B
        --> Module C
      Providers: (Onde serão declarados os service, ver na pática mais a frente ...)
        --> Service A
        --> Service B
        --> Service C
      Bootstrap: (Define o componente que será o primeiro a ser carregado naquele módulo, 
      necessário apena para o módulo que inicia a aplicação; carrega o componente 
      principal na SPA: main.ts --> AppModule --> AppComponent --> ... (que chama os demais componentes da árvore))
        --> AppComponent

  Organização utilizando módulos:

  AppModule                           XModule
    --> Bootstrap                       Declarations | Imports
  Declarations | Imports                Exports      | Providers
          
  YModule                             ZModule 
    Declarations | Imports              Declarations | Imports
    Exports      | Providers            Exports      | Providers

======== Aula 516

CLI do Angula:
  
  Instalando a CLI do Angula de forma global no sistema:
    $ npm i -g @angular/cli
  
  Criando um projeto Angula com estrutura minima, sem teste:
    $ ng new frontendnew --minimal
    
	* Sobre criação de rotas, diz que sim (y): Would you like to add Angular routing? (y/N) y
    * Sobre estilização escolhe-se: CSS
    - Será criada toda a estrutura necessária para trabalhar com o Angula

  Entra na pasta criada do frontendnew:
    $ cd frontendnew
  Inicia o servidor do frontend:
	$ npm start
  Acessa o navegador no endereço:  http://localhost:4200/, para ver a aplicação funcionando
  
======== Aula 517

Ajusta as configurações do arquivo angular.json, nas seguintes configurações:
  "inlineTemplate": false,
  "inlineStyle": false,
Isso é necessário para que os arquivos CSS e HTML fiquem em arquivos separados.
Pois no minimal ele opta por configurar desta forma.

Dentro da pasta do projeto: /frontendnew
    Tem uma pasta chamada:        /src
    Onde ficam os está o:             main.ts (que chama o modulo)
    O AppModule fica dentro da pasta: /app
    Onde estão os arquivos:               app-module.ts (que tem o bootstrap que chama o AppComponent)
                                          app-component.ts (que tem as definições do componente que será renderizado no browser)
                                          app-routing.module.ts (rotas do módulo, estudar mais a frente ...)

Em main.ts é onde está sendo chamado, carregado o nosso módulo principal 
chamado de AppModule que fica na pasta ./src/app/app.module.ts . Nele é chamado
em bootstrap o AppComponent que foi importado e declarado para ser invocado dentro
do AppModule. E por fim ele exporta a si mesmo (AppModule) para ser inicializado por
main.ts.

Podemos observar que AppComponent está com o template no formato inline, 
iremos modificar isso.

- Na pasta /frontendnew/src/assets ficam as images e fontes utilizadas no component.

- Na pasta /frontendnew/src/environments ficam as variáveis de ambiente no 
arquivo environments.ts para desenvolvimento e environments.pord.ts o de produção.

- E temos dentro de /frontendnew/src/index.html que é a SPA (Single Page Application
ou Aplicações de Página Única) que referencia, aponta para o componente raiz através da
tag <app-root></app-root>, pois no arquivo app-component.ts tem como selector: 'app-root',
assim que a aplicação sabe que componente deve carregar, e os outros componentes também serão
carregados nesta nesta única página através do componente raiz.

======== Aula 518

Vamos editar o arquivo app-component.ts para apontar para um arquivo de 
template html e de css externos fazendo o seguinte:
  templateUrl: 'app.component.html',
  styleUrls: ['app.component.css'],
E também vamos criar estes arquivos no mesmo nível da pasta onde está app-component.ts:
  /frontendnew/src/app/app.component.html (Damos este conteúdo ao arquivo: <h1>Component App</h1>)
  /frontendnew/src/app/app.component.css (deixamos este com o conteúdo vazio)

E possível interpolada o valor de uma variável exportada através do uso do {{ }}
no component da em questão, ex.:
  # app-component.ts
  import { Component } from '@angular/core';
  @Component({
    selector: 'app-root',
    templateUrl: 'app.component.html',
    styleUrls: ['app.component.css']
  })
  export class AppComponent {
    title = 'frontendnew'; // title <-- variável em questão
  }
  # E no app.component.html, faríamos
  <h1>Component App</h1>
  <h2>Olá o nome desta aplicação é: {{ title }}</h2> <!-- variável title 
  interpolada através do {{ }} exibindo seu valor no browser. -->

======== Aula 519

Instalando os componentes do Material Design 

1- com a aplicação Angula parada;
2- Executa o seguinte comando:
  $ ng add @angular/material
  Quando da instalação será solicitado escolher as o esquema de cor do projeto,
  selecione o seu preferido:
    * Choose a prebuilt theme name, or "custom" for a custom theme: Indigo/Pink
  Informe se o esquema de tipo de fontes será aplicado para o projeto inteiro:  
    *  Set up global Angular Material typography styles? Yes
  Com relação às animações:
    * Include the Angular animations module? Include and enable animations
  Será feita a instalação conforme as configurações selecionadas.

======== Aula 520

Implementado o componente header (cabeçalho)

Para criar um componente, estando na pasta raiz do projeto frontend (/frontendnew/),
utilizando o terminal, digite o comando:
  $ ng generate component components/template/header # ou de forma resumida
  $ ng g c components/template/header # a ultima parte é o path do component a ser gerado

Serão criado três arquivos no caminho especificado: 
  - header.component.ts;
  - header.component.html; e
  - header.component.css.
  CREATE src/app/components/template/header/header.component.html (21 bytes)
  CREATE src/app/components/template/header/header.component.ts (275 bytes)
  CREATE src/app/components/template/header/header.component.css (0 bytes)
  UPDATE src/app/app.module.ts (604 bytes)
    import { HeaderComponent } from './components/template/header/header.component';
    ...
    declarations: [
    AppComponent,
    HeaderComponent
    ],
    ...
E será atualizado o arquivo app.module.ts que passará a importar o componente 
recentemente criado, conforme visto acima.

Após este processo pode-se ir no app.component.html e acrescentar a tag
<app-header></app-header> isso será suficiente para que o cabeçalho seja
renderizado e irá aparecer no navegador o seguinte: header works! (cabeçalho
funcionando). Agora já podemos trabalhar para estilizar o cabeçalho e deixá-lo
como desejamos.

Vamos trabalhar no template: src/app/components/template/header/header.component.html
mas antes iremos necessitar utilizar um componente que já vem pronto no Material e
temos que importá-lo:
  - No AppModel (src/app/app.module.ts) fazemos o import:
    --> import { MatToolbarModule } from '@angular/material/toolbar'
  
  - Adiciona MatToolbarModule na seção dos importes:
    --> imports: [
      ...
      MatToolbarModule,
      ...
    ]

  - No arquivo header.component.html, faremos a seguinte edição, antes
  adicionamos a imagem logo.png no caminho referenciado:
    <mat-toolbar class="header mat-elevation-z3">
        <span>
            <a>
                <img class="logo" src="assets/img/logo.png" alt="logo">
            </a>
        </span>
        <span class="title-group">
            <a>
                <i class="material-icons">
                    home
                    <!-- dashboard -->
                </i>
                Aplicação CRUD
            </a>
        </span>
    </mat-toolbar>
  
  - Para ajustar a imagem para que fique adequada no tamanho vamos manipular o
  arquivo css header.component.css e estilizar as classes definidas para o header:
    
    .header {
    display: flex;
    align-items: center;
    }

    .header a {
        display: flex;
        align-items: center;
        text-decoration: none;
    }

    .header .logo {
        max-width: 200px;
    }

    .header .title-group{
        padding-left: 25px;
    }

    .header .title-group i {
        padding-right: 5px;
    }

======== Aula 521

Implementado o componente rodapé (Footer)

  1º passo: 
    Para criar um componente, estando na pasta raiz do projeto frontend 
    (/frontendnew/),utilizando o terminal, digite o comando:
      
      $ ng g c components/template/footer # ou de forma resumida
  
  2º passo:
    Já podemos editar o arquivo app.component.html incluindo a tag no componente
    footer que foi criado: <app-footer></app-footer>;
  
  3º passo:
    "Desenhar" com HTML a estrutura do footer e aplicar o estilo necessário
    utilizando o CSS;

    * Estrutura HTML (footer.component.html):

      <mat-toolbar class="footer">
          <span>
              Desenvolvido com
              <i class="material-icons red v-middle">
                  favorite
              </i>
              por <strong>Cod<span class="red">3</span>r</strong>
          </span>
      </mat-toolbar>

    * Estilo CSS (footer.component.css):

      .footer {
          position: fixed;
          bottom: 0;
          display: flex;
          justify-content: flex-end;
      }

      .footer > span {
          font-size: 1.1rem;
          font-weight: 300;
      }


  Exite um arquivo "geral" de estilo CSS que compartilha estilos que são padrões 
  para toda a aplicação. Aqui pode ser definidas classes que podem ser utilizadas
  de forma global na aplicação. Este arquivo fica em ./src/styles.css . Foram
  definidos alguns estilos gerais, também neste aquivo para servir ao footer:
    
    * Estilo Geral CSS (styles.css):

      .red {
          color: rgb(277, 94, 107);
      }

      .v-middle {
          vertical-align: middle;
      }  

======== Aula 522

Implantado o componente de navegação (nav)

  Vamos repetir os mesmos passos da aula anterior só alterando o path de onde os
  arquivos irão ser gerados:

  $ ng g c components/template/nav

  Foram gerados os componentes e agora iremos necessitar utilizar 
  dois componentes que já vem prontos no Material e temos que importá-los:
  - No AppModel (src/app/app.module.ts) fazemos o import:
    --> import { MatSideNavModule } from '@angular/material/sidenav'
    --> import { MatListModule } from '@angular/material/list'
  
  - Adiciona MatSidenavModule e MatListModule na seção dos importes:
    --> imports: [
      ...
      MatSidenavModule,
      MatListModule,
      ...
    ]
  - Inserimos entre header e o footer no arquivo app.component.html 
    a tag no componente de navegação que foi criado: <app-nav></app-nav>
  
  Perceba que assim estamos criando a nossa arvore de componentes dentro de
  nossa app.component.
  
  Fontes de ícones para consulta: https://material.io/resources
  
  Vamos definir agora o nosso nav (para compreender todas as configurações
  do Material é necessário ler a documentação deste módulo para o Angular):

    * Estrutura HTML (footer.component.html):

      <mat-sidenav-container class="container">
          <mat-sidenav class="sidenav" mode="side" opened fixedInViewport="true" fixedTopGap="64">
              <mat-nav-list class="nav-list">
                  <a mat-list-item>
                      <i class="material-icons">
                          home
                      </i>
                      Início
                  </a>
                  <a mat-list-item>
                      <i class="material-icons">
                          storefront
                      </i>
                      Produtos
                  </a>
              </mat-nav-list>
          </mat-sidenav>
      </mat-sidenav-container>

    * Estilo CSS (footer.component.css):

    .sidenav {
    background-color: #3f51b5;
    width: 200px;
    }

    .sidenav a {
        color: #fff;
    }

    .sidenav i {
        padding-right: 10px;
    }

======== Aula 523

Elementos do Angular, aula teórica #01 de 03

1- Componentes (módulos);

2- Diretivas (altera estilo ou estrutura do HTML);
  * Diretiva de Atributo;
  * Diretiva Estrutural
  
3- Bindes (ligação / comunicação entre TS e HTML): 
  * Property (de atributos), 
    + One Way Data (),
    + Two Way Data ().
  * Event (de evento).

4- Rotas (navegação entre os componentes);
5- Pipes (processamentos dentro da página);
6- Observables (programação reativa);
7- Services;
8- Injeção de dependência;

1. Componentes:
  - Formados por três partes (HTML, CSS e TS), não necessariamente precisa ter o
  estilo (css);
  - O componente tem o seu próprio escopo, seu mundo interno. Isso quer diz que, 
  por exemplo, estilos aplicados ao componente fica restrito ao componente;

2. Diretivas:
    2.1 Diretiva de Atributo:
      - Altera a aparência (alterar o CSS) e/ou comportamento (altera o TS ou JS:
      faz chamada Ajax ao backend, por exemplo) de um elemento, componente ou 
      outra diretiva;

      - Estas diretivas são utilizadas na tag do elemento HTML da seguinte forma,
      ex.: <tag class="name-class" nomeDiretiva></tag>;

      Ex. de uma diretiva de atributo (Attribute Directives):
        @Directive({
            selector: '[appRed]' // <== CHAMADA / APELIDO DA DIRETIVA 
        })
          export class RedDirective {
            constructor(el: ElementRef){
              el.nativeElement.style.color = '#e35e66b';
            }
        }
      => Ex. da chamada da diretiva no HTML >> alterando o estilo / aparência 
        de um elemento:
        
        <i class="material-icons v-middle"> <!-- coração preto -->
          favorite
        </i>
        
        <i class="material-icons v-middle" appRed> <!-- coração vermelho com a chamada da diretiva appRed -->
          favorite
        </i>

    2.2 Diretiva Estrutural:
      - Altera o layout adicionando e/ou removendo elementos do DOM, altera a
      estrutura HTML do elemento;

      - Estas diretivas são utilizadas na tag do elemento HTML precedidas de um
      asterisco, ex.: <tag class="name-class" *nomeDiretiva></tag>; 
      
      Ex. de uma diretiva de estrutura (Structural Directives) que já vem 
      embutida no Angula a *ngIf e a *ngFor. São dois exemplos de vários outros
      que existem no Angular:

      <form *ngIf="product" class="product-form">
      </form>
      => Neste exemplo, se (*ngIf) produto for definido / setado ele será 
      exibido. A condição a ser avaliada é declarada dentro de aspas conforme
      visto acima;
      
      <ul>
        <li *ngFor="let product of products">
        </li>
      </ul>
      => Neste exemplo, Será realizada uma iteração (*ngFor) em products e para
      cada product será exibido um elemento na lista não ordenada. A condição 
      da iteração é declarada dentro de aspas;
  
  3. Binding:
    
    3.1 Property Binding (Binding de Atributo)
      - Quando se quer "pegar" dados / informações que estão nos componentes TS
      e passar para a tag HTML (componentes são pequenas aplicações onde deve 
      existir comunicação entre o arquivo TS com o arquivo HTML) uma das formas 
      de estabelecer esta comunicação entre TypeScript e o HTML é através de 
      Property Binding ou Binding de atributo. Conforme exemplo abaixo:

        => TS
          @Component({
            selector: 'app-product-read',
            templateUrl: './product-read.component.html',
            styleUrl: './product-read.component.css'
          })
          
          export class ProductReadComponent implements OnInit {
            products: Product[] // propriedade product criada como array de Product
          }
        =====> No arquivo TS acima foi criado o componente app-product-read e 
        exposto para fora através da classe ProductReadComponent o atributo 
        products que poderá ser utilizado no HTML do componente para popular uma
        tabela com os respectivos elementos deste array (products).
        
        => HTML
          <table [dataSource]="products">
          </table>
        =====> Para acessar esse array de produtos no HTML é preciso ter algum
        tipo de sintaxe / sinalização para informar que ele irá acessar a variável
        products criada no TS, dentro do componente. E a forma que se tem para
        estabelecer esta comunicação e colocar o atributo que ser quer passar o
        valor da variável entre colchetes []. Como foi realizado no exemplo anterior
        com [dataSource]="products". Se dataSource não for colocado entre [] o
        angular vai interpretar que o valor passado é um string comum igual em 
        uma tag HTML comum. Mas quando é utilizado os colchetes para envolver a 
        propriedade dataSource ele vai olhar para o componente procurando um
        atributo com o nome que se encontra entre aspas "" apos o = que tenha o
        mesmo nome, no caso products. Aí ele vai pegar o array associado a esta
        variável passar para o HTML para montar a tabela de produtos. Então a forma
        que se tem de fazer uma ligação (Binding) entre o HTML e o TS e envolvendo
        as propriedades HTML em colchetes [] e passando o nome da variável TS como
        string para este atributo, dataSource não é um atributo comum para tabela
        porém é utilizado pelo MaterialDesign, que está sendo utilizado, para pode
        renderizar a tabela com seus dados.
      
      3.1.1 On Way Data Binding (Apenas um sentido de ligação de dados) TS --> HTML
        -  Quando se deseja que a comunicação entre o TS e o HTML seja de sentido
        único do TS --> para o HTML a sintaxe utilizada é esta apresentada anteriormente,
        ou seja, utiliza-se os colchetes [] envolvendo a propriedade HTML que irá
        receber o valor da variável quando ela for alterada no TS. Assim as alterações
        no valor da variável só ocorrem no sentido do TS para o HTML, como pode
        ser visto no exemplo abaixo:
          
          => TS
            @Component({
              selector: 'app-product-read',
              templateUrl: './product-read.component.html',
              styleUrl: './product-read.component.css'
            })
            
            export class ProductReadComponent implements OnInit {
              nomeCliente: string // propriedade nome
              //...
              nomeCliente = "Paulo" // variável sofrendo alteração de valor
            }
          =====> O atributo nomeCliente é criado e exposto no TS. Quando seu valor
          é alterado no script ele envia uma notificação para o HTML e altera o 
          valor da propriedade definida lá pelo novo valor da variável.
          
          => HTML
            <input [value]="nomeCliente">
          =====> No HTML a variável nomeCliente é invocada através da propriedade
          value que está sinalizada pela sintaxe de [] no input que irá receber 
          sempre o valor desta variável quando ela for alterada no TS 
          (On Way Data Binding) TS --> HTML .

      3.1.2 Two Way Data Binding (Sentido duplo de ligação de dados) TS <--> HTML
        -  Quando se deseja que a comunicação entre o TS e o HTML seja de sentido
        duplo, ou seja, alterações no conteúdo da propriedade HTML se reflitam no
        TS e vice-versa, a sintaxe para sinalizar este comportamento do biding é
        outra utiliza-se a combinação dos colchetes com os parenteses [()] envolvendo
        a propriedade que se deseja que se comporte como Two Way Data Binding,
        como pode ser visto no exemplo abaixo:
          
          => TS
            @Component({
              selector: 'app-product-read',
              templateUrl: './product-read.component.html',
              styleUrl: './product-read.component.css'
            })
            
            export class ProductReadComponent implements OnInit {
              nomeCliente: string // propriedade nome
              //...
              nomeCliente = "Paulo" // variável sofrendo alteração de valor
            }
          =====> O mesmo exemplo anterior, o atributo nomeCliente é criado e 
          exposto no TS. Quando seu valor é alterado no script ele envia uma 
          notificação para o HTML e altera o valor da propriedade definida lá 
          pelo novo valor da variável e quando o valor for alterado no HTML isso
          também irá alterar o valor no TS do componente. 
          
          => HTML
            <input [(ngModel)]="nomeCliente"> <!-- caso o usurário digite Renato no input isso se refletirá no TS -->
          =====> No HTML a variável nomeCliente é invocada através da propriedade
          value que está sinalizada pela sintaxe de colchetes e parenteses com a
          chamada ngModel dentro  [(ngModel)] no input que irá receber sempre o 
          valor desta variável quando ela for alterada no TS e quando o usurário 
          alterar o valor do input isso se refletirá também 
          no TS (Two Way Data Binding) TS <--> HTML . Esta sintaxe e bastante usada
          para trabalhar com formulários. 

    3.2 Event Binding (Binding de Evento)
      - Quando se deseja ligar, ou seja, fazer um biding entre um evento do HTML
      com um método criado no componente no arquivo TS. Faz-se algo semelhante ao
      biding de atributo com uma pequena diferença: a sintaxe / sinalização para
      isso é modificada ou seja o evento no HTML será envolvido com parenteses ()
      para realizar o biding de evento, conforme exemplo abaixo:

        => TS
          @Component({
            selector: 'app-product-create',
            templateUrl: './product-create.component.html',
            styleUrl: './product-create.component.css'
          })
          
          export class ProductCreateComponent implements OnInit {
            // ...
            createProduct(): void { // método createProduct que será exposto 
              //...
            }
            // ...
          } 
        =====> No arquivo TS acima foi criado o componente app-product-create e 
        exposto para fora através da classe ProductCreateComponent onde o método
        createProduct() poderá ser invocado via biding de evento no HTML do
        componente.

        => HTML
          <button mat-raised-button
            (click)="createProduct()" // evento click envolvido na sintaxe de ()
            color="primary">
            Salvar
          </button>
        =====> Para acessar o método createProduct() no HTML é preciso sintaxe /
        sinalização de () envolvendo o nome do evento que se deseja realizar a
        ligação / biding e logo após o igual = dentro das aspas "" informar o
        nome do método que se deseja invocar acompanhado dos parenteses, conforme
        no exemplo acima, reproduzido aqui: (click)="createProduct()"

  4. Router (Rotas):
    
    - Dado um conjunto de componentes que foram criado deseja-se navegar ou alternar
    entre eles ir e voltar, ex.:
      
      ==> /home    vá para --> [Componente Home] 
      ==> /produto vá para --> [Componente Produto] 
      ==> /usuario vá para --> [Componente Usuário]

    - Então como fazer isso? Faz-se o mapeamento entre uma URL e o componente que
    se deseja exibir, conforme exemplificado acima através do sistema de rotas do
    Angular.

    - Como isso funciona, ex.:
      * Na estrutura da página index.html exite a seguinte estrutura:
        
        + Um componente NAV com as seguintes opções [ HOME | PRODUTO | USUÁRIO ]
        
        + Uma área chamada de [Route Outlet] (ou seja, exibe a saída/componente 
          da rota que foi selecionada). Por exemplo se a rota selecionada for 
          /home clicando no NAV no link HOME, na área de saída da rota será exibido
          o [Componente Home] e assim sucessivamente para os demais links no NAV
          alteração o conteúdo exibido nesta região.
        
        + [Route Outlet] também é um componente e esse componente vai injetar dentro
          dele os componentes de acordo com a navegação que for realizada, em tese,
          representa a região de renderização dos componentes de uma rota.
          ela é definida no nosso template HTML da página index.html (nossa SPA)
          através da tag <router-outlet></router-outlet> ou dentro de um outro
          componente qualquer.
    
    - Abaixo segue um exemplo de trechos de código de como isso funciona:
      
      => nav.component.html [fragmento do html do componente]
        <a routerLink="/products"
          Produtos
        </a>
      =====> A propriedade routerLink vai olhar para o arquivo app-routing.module.ts
      de rotas procurando um objeto na lista Routes que possui uma propriedade 
      path que seja igual a string informada, encontrado o path que coincide 
      retorna o componente que está mapeada no objeto na propriedade component,
      conforme fragmento abaixo.
      
      => app-routing.module.ts [fragmento do html do componente]
      const routes: Routes = [{
          path: "products",
          component: ProductCrudComponent
        }, {
          path: "products/create",
          component: ProductCreateComponent
        }];
      =====> Neste caso, localiza o path products então carrega e retorna 
      o component ProductCrudComponent que será injetado no componente 
      router-outlet para que seja renderizado, conforme fragmento a seguir.

      => nav.component.html [fragmento do html do componente, que poderia ser outro qualquer]
        <mat-sidenav-content>
            <router-outlet></router-outlet>
        </mat-sidenav-content>
      =====> Neste exemplo, o componente ProductCreateComponent será injetado
      dentro de router-outlet que está inserido em um outro componente 
      mat-sidenav-content .

  5. Pipes (Processamentos de variáveis no HTML):
    
    - São processamentos realizados em cima de variáveis no HTML. Uma das 
    características dos pipes é a possibilidade de conectar o resultado obtido
    com um processamento de um pipe e passá-lo para ser processado em outro 
    pipe como se fosse conexões de tubos um encadeamento, veja exemplos:

    => Pipe para processamento de datas:
    <p>
      O vencimento é {{ produto.vencimento | date }}
    </p>
    =====> Suponhamos que o formato da data que vem do banco de dados é o que se
    adequada para ser exibido para o usuário, nesse caso estamos processando para
    exibir a data, aplicando uma formatação diferente.

     => Pipe também podem receber parâmetros, como no caso no exemplo a seguir:
    <td>
      {{ row.price | currency: 'BRL' }}
    </td>
    =====> Processa o preço para que se apresente no formato de moeda e recebe o
    parâmero após os : com 'BRL' para identificar que é no formato da moeda do
    Brasil. Por baixo dos panos o pipe chama uma função para realizar o processamento.

    => Pipe realizando processamentos em cadeia (chaining):
    <p>
      O vencimento é {{ produto.vencimento | date: 'fullDate' | uppercase }}
    </p>
    =====> No caso acima recebemos uma data processamos para mostrá-lo completa
    por extenso e depois processamos novamente para colocar tudo em letras 
    maiúsculas.

======== Aula 522

6. Observable (Programação Reativa - ReactiveX):